stages:
  - test
  - build_and_push
  - deploy
  - deploy-with-docker-api

variables:
  PYTHON_VERSION: "3.10"
  VENV_DIR: ".venv"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""
  DOCKER_REGISTRY: "registry.infosec.it.ubc.ca"
  DOCKER_USERNAME: $CI_REGISTRY_USER
  DOCKER_PASSWORD: $CI_REGISTRY_PASSWORD
  IMAGE_NAME: "ubc/cybersecurity/services/ciso/itsa-test-project/make-python-devex-bt"
  BIND_PORT: "8080"               # Define the port to bind on the host for docker container


default:
  image: python:${PYTHON_VERSION}

services:
  - name: docker:19-dind
    alias: docker

test:
  stage: test
  script:
    # Check if Homebrew is installed as non root user; if not, install it using Makefile
    - if ! command -v brew &>/dev/null; then
        echo "Homebrew not found. Installing with Makefile...";
        make install-homebrew;
      else
        echo "Homebrew is already installed.";
      fi

    # Verify Homebrew installation for non root user
    - export PATH="/home/linuxbrew/.linuxbrew/bin:$PATH"
    - eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
    - brew --version

    # Verify Homebrew installation
    - brew --version

    # Set up Python environment
    - python3 -m venv ${VENV_DIR}
    - source ${VENV_DIR}/bin/activate
    - pip install --upgrade pip

    # Install Poetry
    - curl -sSL https://install.python-poetry.org | python3 -
    - export PATH="/root/.local/bin:$PATH"  # Add Poetry to PATH

    # Verify Poetry installation
    - poetry --version
    - poetry env use python3

    # Install dependencies with Makefile
    - make deps || { echo "Makefile dependency installation failed"; exit 1; }
    - make test || { echo "Tests failed"; exit 1; }
    - make build || { echo "Build failed"; exit 1; }

  artifacts:
    paths:
      - .
      - dist/
    expire_in: 1 day

build_and_push:
  stage: build_and_push
  tags:
    - docker-in-docker # this forces the CI job to on the dedicated DinD runner
  image: docker:20.10  # Use a Docker image with Docker CLI preinstalled
  # variables:
  #   DOCKER_TLS_CERTDIR: ""
  #   DOCKER_HOST: "tcp://docker:2375"  # Explicitly set the Docker host
  script:
    # Generate unique artifact version based on commit hash and pipeline ID
    - export COMMIT_ID=$(echo $CI_COMMIT_SHORT_SHA)
    - export PIPELINE_ID=$(echo $CI_PIPELINE_ID)
    - export IMAGE_TAG="0.0.0-${COMMIT_ID}-${PIPELINE_ID}"

    # Save the build version as a CI/CD variable
    - echo "IMAGE_TAG=$IMAGE_TAG" > build_version.txt

    # # Save build metadata
    # - mkdir -p .build_metadata
    # - echo "COMMIT_ID=$COMMIT_ID" > .build_metadata/build_info.txt
    # - echo "PIPELINE_ID=$PIPELINE_ID" >> .build_metadata/build_info.txt
    # - echo "BUILD_VERSION=$BUILD_VERSION" >> .build_metadata/build_info.txt

    # Authenticate with the Docker registry
    - echo $DOCKER_PASSWORD | docker login $DOCKER_REGISTRY --username $DOCKER_USERNAME --password-stdin

    # Build the Docker image
    - docker build -t $DOCKER_REGISTRY/$IMAGE_NAME:$IMAGE_TAG .

    # Push the Docker image to the registry
    - docker push $DOCKER_REGISTRY/$IMAGE_NAME:$IMAGE_TAG
  artifacts:
    paths:
      - build_version.txt
    expire_in: 1 day

# deploy:
#   stage: deploy
#   tags:
#     - docker-in-docker # this forces the CI job to on the dedicated DinD runner
#   image: docker:20.10  # Use a Docker image with Docker CLI preinstalled
#   before_script:
#     # Set up SSH for deployment
#     - mkdir -p ~/.ssh
#     - echo "$PRIVATE_KEY_dev_spielplatz_Server" | tr -d '\r' > ~/.ssh/id_rsa
#     - chmod 600 ~/.ssh/id_rsa
#     - eval "$(ssh-agent -s)"
#     - ssh-add ~/.ssh/id_rsa

#     # Add the target VM to known_hosts to prevent interactive prompts
#     - ssh-keyscan -H dev-spielplatz.misc.devl.infosec.it.ubc.ca >> ~/.ssh/known_hosts

#   script:
#     - echo "Deploying the Docker container to the target VM..."
#     # # Export necessary variables for the deployment script
#     # - export DOCKER_USERNAME=$SSHKP_USERNAME
#     # - export DOCKER_PASSWORD=$SSHKP_PASSWORD
#     # Load the build version
#     - export IMAGE_TAG=$(cat build_version.txt)

#     # Debugging variables
#     - echo "$IMAGE_TAG"
#     - echo "$BIND_PORT"
#     - echo "$SSHKP_USERNAME"
#     - echo "$SSHKP_PASSWORD"
#     - env | sort

#     # Run deploy.sh on the target VM with the required parameters
#     - ssh itsa-svc-spielplatz-gitlab@dev-spielplatz.misc.devl.infosec.it.ubc.ca "bash /home/eldap_prov_prod/itsa-svc-spielplatz-gitlab/deploy.sh $IMAGE_TAG $BIND_PORT $DOCKER_USERNAME $DOCKER_PASSWORD"
#     # - ssh itsa-svc-spielplatz-gitlab@dev-spielplatz.misc.devl.infosec.it.ubc.ca "bash /home/eldap_prov_prod/itsa-svc-spielplatz-gitlab/deploy.sh 0.0.0-c790aedc-5450 8000 bthoma02 glpat-AhYv5xkKPWKSGGBSpGQ8"


deploy-with-docker-api:
  stage: deploy-with-docker-api
  tags:
    - docker-in-docker # this forces the CI job to run on the dedicated DinD runner
  image: docker:20.10
  variables:
    DOCKER_HOST: tcp://10.93.46.34:8080  # Remote Docker API
  script:
    # Debugging: Test basic connectivity to the target server
    - echo "Testing connectivity to 10.93.46.34"
    - apk add --no-cache iputils bind-tools curl net-tools
    - ping -c 4 10.93.46.34 || echo "Ping to 10.93.46.34 failed"
    - curl -v http://10.93.46.34:8080/version || echo "Docker API endpoint /version failed"
    - echo "Environment Variables:"
    - env | sort

    # Test connectivity to the Docker daemon
    - echo "Testing connection to Docker daemon via DOCKER_HOST=$DOCKER_HOST"
    - docker info

    # Load the build version
    - export IMAGE_TAG=$(cat build_version.txt)

    # Authenticate with the Docker registry
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $DOCKER_REGISTRY

    # Pull the Docker image
    - docker pull $DOCKER_REGISTRY/$IMAGE_NAME:$IMAGE_TAG

    # Run the container on the remote host
    - docker stop make-python-devex-bt || true
    - docker rm make-python-devex-bt || true
    - docker run -d --name make-python-devex-bt -p $BIND_PORT:8000 $DOCKER_REGISTRY/$IMAGE_NAME:$IMAGE_TAG
