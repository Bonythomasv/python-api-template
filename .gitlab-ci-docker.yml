stages:
  - test
  - build_and_push

variables:
  PYTHON_VERSION: "3.10"
  VENV_DIR: ".venv"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""
  DOCKER_REGISTRY: "registry.infosec.it.ubc.ca"
  DOCKER_USERNAME: $CI_REGISTRY_USER
  DOCKER_PASSWORD: $CI_REGISTRY_PASSWORD
  IMAGE_NAME: "ubc/cybersecurity/services/ciso/itsa-test-project/make-python-devex-bt"
  IMAGE_TAG: "latest"

default:
  image: python:${PYTHON_VERSION}

services:
  - name: docker:19-dind
    alias: docker

test:
  stage: test
  script:
    # Check if Homebrew is installed as non root user; if not, install it using Makefile
    - if ! command -v brew &>/dev/null; then
        echo "Homebrew not found. Installing with Makefile...";
        make install-homebrew;
      else
        echo "Homebrew is already installed.";
      fi

    # Verify Homebrew installation for non root user
    - export PATH="/home/linuxbrew/.linuxbrew/bin:$PATH"
    - eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
    - brew --version

    # Verify Homebrew installation
    - brew --version

    # Set up Python environment
    - python3 -m venv ${VENV_DIR}
    - source ${VENV_DIR}/bin/activate
    - pip install --upgrade pip

    # Install Poetry
    - curl -sSL https://install.python-poetry.org | python3 -
    - export PATH="/root/.local/bin:$PATH"  # Add Poetry to PATH

    # Verify Poetry installation
    - poetry --version
    - poetry env use python3

    # Install dependencies with Makefile
    - make deps || { echo "Makefile dependency installation failed"; exit 1; }
    - make test || { echo "Tests failed"; exit 1; }
    - make build || { echo "Build failed"; exit 1; }

  artifacts:
    paths:
      - .
      - dist/
    expire_in: 1 day

build_and_push:
  stage: build_and_push
  tags:
    - docker-in-docker # this forces the CI job to on the dedicated DinD runner
  image: docker:20.10  # Use a Docker image with Docker CLI preinstalled
  # variables:
  #   DOCKER_TLS_CERTDIR: ""
  #   DOCKER_HOST: "tcp://docker:2375"  # Explicitly set the Docker host
  script:
    # Generate unique artifact version based on commit hash and pipeline ID
    - export COMMIT_ID=$(echo $CI_COMMIT_SHORT_SHA)
    - export PIPELINE_ID=$(echo $CI_PIPELINE_ID)
    - export BUILD_VERSION="0.0.0-${COMMIT_ID}-${PIPELINE_ID}"

    # Save build metadata
    - mkdir -p .build_metadata
    - echo "COMMIT_ID=$COMMIT_ID" > .build_metadata/build_info.txt
    - echo "PIPELINE_ID=$PIPELINE_ID" >> .build_metadata/build_info.txt
    - echo "BUILD_VERSION=$BUILD_VERSION" >> .build_metadata/build_info.txt

    # Adjust the image tag
    - export IMAGE_TAG=$BUILD_VERSION

    # Authenticate with the Docker registry
    - echo $DOCKER_PASSWORD | docker login $DOCKER_REGISTRY --username $DOCKER_USERNAME --password-stdin

    # Build the Docker image
    - docker build -t $DOCKER_REGISTRY/$IMAGE_NAME:$IMAGE_TAG .

    # Push the Docker image to the registry
    - docker push $DOCKER_REGISTRY/$IMAGE_NAME:$IMAGE_TAG

# deploy:
#   stage: deploy
#   tags:
#     - ssh  # Ensure the runner can SSH into the target VM
#   script:
#     # Variables for the target VM
#     - export VM_USER="your-vm-user"
#     - export VM_HOST="your-vm-ip"
#     - export SSH_KEY="/path/to/ssh/private/key" # Add to CI/CD variables for security

#     # Copy SSH key for authentication
#     - mkdir -p ~/.ssh
#     - echo "$SSH_KEY" > ~/.ssh/id_rsa
#     - chmod 600 ~/.ssh/id_rsa

#     # Deploy the Docker container to the VM
#     - ssh -o StrictHostKeyChecking=no $VM_USER@$VM_HOST << EOF
#         echo "Authenticating Docker on the target VM...";
#         echo $DOCKER_PASSWORD | docker login $DOCKER_REGISTRY --username $DOCKER_USERNAME --password-stdin;

#         echo "Pulling the Docker image...";
#         docker pull $DOCKER_REGISTRY/$IMAGE_NAME:$IMAGE_TAG;

#         echo "Stopping any running container...";
#         docker stop make-python-devex || true;
#         docker rm make-python-devex || true;

#         echo "Starting a new container...";
#         docker run -d --name make-python-devex -p 8080:8000 $DOCKER_REGISTRY/$IMAGE_NAME:$IMAGE_TAG;
#         echo "Deployment completed.";
#     EOF
